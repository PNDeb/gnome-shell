From: Lubomir Rintel <lkundrak@v3.sk>
Date: Tue, 31 Oct 2017 11:38:20 +0100
Subject: network: port to libnm

The libnm-glib is depreacted for a long time already.

https://bugzilla.gnome.org/show_bug.cgi?id=789811
(cherry picked from commit d71af5e5795bba3a3d5557cfccaca9d2adcd03a2)
---
 js/misc/modemManager.js          |   4 +-
 js/ui/components/networkAgent.js |  25 ++--
 js/ui/status/network.js          | 312 ++++++++++++++++++---------------------
 meson.build                      |   8 +-
 src/meson.build                  |   2 +-
 src/shell-network-agent.c        | 221 ++++++++++++---------------
 src/shell-network-agent.h        |   8 +-
 7 files changed, 257 insertions(+), 323 deletions(-)

diff --git a/js/misc/modemManager.js b/js/misc/modemManager.js
index 0e6046f..90474e2 100644
--- a/js/misc/modemManager.js
+++ b/js/misc/modemManager.js
@@ -2,7 +2,7 @@
 
 const Gio = imports.gi.Gio;
 const Lang = imports.lang;
-const NMGtk = imports.gi.NMGtk;
+const NMA = imports.gi.NMA;
 const Signals = imports.signals;
 
 // _getMobileProvidersDatabase:
@@ -14,7 +14,7 @@ let _mpd;
 function _getMobileProvidersDatabase() {
     if (_mpd == null) {
         try {
-            _mpd = new NMGtk.MobileProvidersDatabase();
+            _mpd = new NMA.MobileProvidersDatabase();
             _mpd.init(null);
         } catch (e) {
             log(e.message);
diff --git a/js/ui/components/networkAgent.js b/js/ui/components/networkAgent.js
index b6a3456..6e36441 100644
--- a/js/ui/components/networkAgent.js
+++ b/js/ui/components/networkAgent.js
@@ -5,8 +5,7 @@ const Gio = imports.gi.Gio;
 const GLib = imports.gi.GLib;
 const GObject = imports.gi.GObject;
 const Lang = imports.lang;
-const NetworkManager = imports.gi.NetworkManager;
-const NMClient = imports.gi.NMClient;
+const NM = imports.gi.NM;
 const Pango = imports.gi.Pango;
 const Shell = imports.gi.Shell;
 const St = imports.gi.St;
@@ -173,7 +172,7 @@ var NetworkSecretDialog = new Lang.Class({
 
     _validateStaticWep: function(secret) {
         let value = secret.value;
-        if (secret.wep_key_type == NetworkManager.WepKeyType.KEY) {
+        if (secret.wep_key_type == NM.WepKeyType.KEY) {
             if (value.length == 10 || value.length == 26) {
 		for (let i = 0; i < value.length; i++) {
                     if (!((value[i] >= 'a' && value[i] <= 'f')
@@ -189,7 +188,7 @@ var NetworkSecretDialog = new Lang.Class({
                 }
             } else
                 return false;
-	} else if (secret.wep_key_type == NetworkManager.WepKeyType.PASSPHRASE) {
+	} else if (secret.wep_key_type == NM.WepKeyType.PASSPHRASE) {
 	    if (value.length < 0 || value.length > 64)
 	        return false;
 	}
@@ -288,7 +287,7 @@ var NetworkSecretDialog = new Lang.Class({
         switch (connectionType) {
         case '802-11-wireless':
             wirelessSetting = this._connection.get_setting_wireless();
-            ssid = NetworkManager.utils_ssid_to_utf8(wirelessSetting.get_ssid());
+            ssid = NM.utils_ssid_to_utf8(wirelessSetting.get_ssid().get_data());
             content.title = _("Authentication required by wireless network");
             content.message = _("Passwords or encryption keys are required to access the wireless network “%s”.").format(ssid);
             this._getWirelessSecrets(content.secrets, wirelessSetting);
@@ -351,9 +350,9 @@ var VPNRequestHandler = new Lang.Class({
                    ];
         if (authHelper.externalUIMode)
             argv.push('--external-ui-mode');
-        if (flags & NMClient.SecretAgentGetSecretsFlags.ALLOW_INTERACTION)
+        if (flags & NM.SecretAgentGetSecretsFlags.ALLOW_INTERACTION)
             argv.push('-i');
-        if (flags & NMClient.SecretAgentGetSecretsFlags.REQUEST_NEW)
+        if (flags & NM.SecretAgentGetSecretsFlags.REQUEST_NEW)
             argv.push('-r');
         if (authHelper.supportsHints) {
             for (let i = 0; i < hints.length; i++) {
@@ -580,7 +579,7 @@ var NetworkAgent = new Lang.Class({
 
     _init: function() {
         this._native = new Shell.NetworkAgent({ identifier: 'org.gnome.Shell.NetworkAgent',
-                                                capabilities: NMClient.SecretAgentCapabilities.VPN_HINTS
+                                                capabilities: NM.SecretAgentCapabilities.VPN_HINTS
                                               });
 
         this._dialogs = { };
@@ -597,6 +596,12 @@ var NetworkAgent = new Lang.Class({
 
         this._native.connect('new-request', Lang.bind(this, this._newRequest));
         this._native.connect('cancel-request', Lang.bind(this, this._cancelRequest));
+        try {
+            this._native.init(null);
+        } catch(e) {
+            this._native = null;
+            logError(e, 'error initializing the NetworkManager Agent');
+        }
 
         this._enabled = false;
     },
@@ -634,7 +639,7 @@ var NetworkAgent = new Lang.Class({
         switch (connectionType) {
         case '802-11-wireless':
             let wirelessSetting = connection.get_setting_wireless();
-            let ssid = NetworkManager.utils_ssid_to_utf8(wirelessSetting.get_ssid());
+            let ssid = NM.utils_ssid_to_utf8(wirelessSetting.get_ssid());
             title = _("Authentication required by wireless network");
             body = _("Passwords or encryption keys are required to access the wireless network “%s”.").format(ssid);
             break;
@@ -689,7 +694,7 @@ var NetworkAgent = new Lang.Class({
             return;
         }
 
-        if (!(flags & NMClient.SecretAgentGetSecretsFlags.USER_REQUESTED))
+        if (!(flags & NM.SecretAgentGetSecretsFlags.USER_REQUESTED))
             this._showNotification(requestId, connection, settingName, hints, flags);
         else
             this._handleRequest(requestId, connection, settingName, hints, flags);
diff --git a/js/ui/status/network.js b/js/ui/status/network.js
index 9575af7..d690484 100644
--- a/js/ui/status/network.js
+++ b/js/ui/status/network.js
@@ -6,9 +6,7 @@ const Gio = imports.gi.Gio;
 const Gtk = imports.gi.Gtk;
 const Lang = imports.lang;
 const Mainloop = imports.mainloop;
-const NetworkManager = imports.gi.NetworkManager;
-const NMClient = imports.gi.NMClient;
-const NMGtk = imports.gi.NMGtk;
+const NM = imports.gi.NM;
 const Signals = imports.signals;
 const Shell = imports.gi.Shell;
 const St = imports.gi.St;
@@ -43,9 +41,9 @@ const NMAccessPointSecurity = {
 var MAX_DEVICE_ITEMS = 4;
 
 // small optimization, to avoid using [] all the time
-const NM80211Mode = NetworkManager['80211Mode'];
-const NM80211ApFlags = NetworkManager['80211ApFlags'];
-const NM80211ApSecurityFlags = NetworkManager['80211ApSecurityFlags'];
+const NM80211Mode = NM['80211Mode'];
+const NM80211ApFlags = NM['80211ApFlags'];
+const NM80211ApSecurityFlags = NM['80211ApSecurityFlags'];
 
 var PortalHelperResult = {
     CANCELLED: 0,
@@ -74,18 +72,6 @@ const PortalHelperIface = '<node> \
 </node>';
 const PortalHelperProxy = Gio.DBusProxy.makeProxyWrapper(PortalHelperIface);
 
-function ssidCompare(one, two) {
-    if (!one || !two)
-        return false;
-    if (one.length != two.length)
-        return false;
-    for (let i = 0; i < one.length; i++) {
-        if (one[i] != two[i])
-            return false;
-    }
-    return true;
-}
-
 function signalToIcon(value) {
     if (value > 80)
         return 'excellent';
@@ -99,16 +85,14 @@ function signalToIcon(value) {
 }
 
 function ssidToLabel(ssid) {
-    let label = NetworkManager.utils_ssid_to_utf8(ssid);
+    let label = NM.utils_ssid_to_utf8(ssid.get_data());
     if (!label)
         label = _("<unknown>");
     return label;
 }
 
-function ensureActiveConnectionProps(active, settings) {
-    if (!active._connection) {
-        active._connection = settings.get_connection_by_path(active.connection);
-
+function ensureActiveConnectionProps(active, client) {
+    if (!active._primaryDevice) {
         // This list is guaranteed to have only one device in it.
         let device = active.get_devices()[0]._delegate;
         active._primaryDevice = device;
@@ -162,7 +146,7 @@ var NMConnectionItem = new Lang.Class({
         if (this._activeConnection == null)
             return false;
 
-        return this._activeConnection.state <= NetworkManager.ActiveConnectionState.ACTIVATED;
+        return this._activeConnection.state <= NM.ActiveConnectionState.ACTIVATED;
     },
 
     _sync: function() {
@@ -346,10 +330,9 @@ var NMConnectionDevice = new Lang.Class({
     Extends: NMConnectionSection,
     Abstract: true,
 
-    _init: function(client, device, settings) {
+    _init: function(client, device) {
         this.parent(client);
         this._device = device;
-        this._settings = settings;
         this._description = '';
 
         this._autoConnectItem = this.item.menu.addAction(_("Connect"), Lang.bind(this, this._autoConnect));
@@ -363,12 +346,12 @@ var NMConnectionDevice = new Lang.Class({
         if (this._client.primary_connection != this._device.active_connection)
             return true;
 
-        return this._client.connectivity == NetworkManager.ConnectivityState.FULL;
+        return this._client.connectivity == NM.ConnectivityState.FULL;
     },
 
     _autoConnect: function() {
-        let connection = new NetworkManager.Connection();
-        this._client.add_and_activate_connection(connection, this._device, null, null);
+        let connection = new NM.SimpleConnection();
+        this._client.add_and_activate_connection_async(connection, this._device, null, null, null);
     },
 
     destroy: function() {
@@ -386,17 +369,12 @@ var NMConnectionDevice = new Lang.Class({
 
     _activeConnectionChanged: function() {
         if (this._activeConnection) {
-            let item = this._connectionItems.get(this._activeConnection._connection.get_uuid());
+            let item = this._connectionItems.get(this._activeConnection.connection.get_uuid());
             item.setActiveConnection(null);
+            this._activeConnection = null;
         }
 
-        this._activeConnection = this._device.active_connection;
-
-        if (this._activeConnection) {
-            ensureActiveConnectionProps(this._activeConnection, this._settings);
-            let item = this._connectionItems.get(this._activeConnection._connection.get_uuid());
-            item.setActiveConnection(this._activeConnection);
-        }
+        this._sync();
     },
 
     _deviceStateChanged: function(device, newstate, oldstate, reason) {
@@ -408,8 +386,8 @@ var NMConnectionDevice = new Lang.Class({
         /* Emit a notification if activation fails, but don't do it
            if the reason is no secrets, as that indicates the user
            cancelled the agent dialog */
-        if (newstate == NetworkManager.DeviceState.FAILED &&
-            reason != NetworkManager.DeviceStateReason.NO_SECRETS) {
+        if (newstate == NM.DeviceState.FAILED &&
+            reason != NM.DeviceStateReason.NO_SECRETS) {
             this.emit('activation-failed', reason);
         }
 
@@ -421,7 +399,7 @@ var NMConnectionDevice = new Lang.Class({
     },
 
     activateConnection: function(connection) {
-        this._client.activate_connection(connection, this._device, null, null);
+        this._client.activate_connection_async(connection, this._device, null, null, null);
     },
 
     deactivateConnection: function(activeConnection) {
@@ -440,7 +418,18 @@ var NMConnectionDevice = new Lang.Class({
     _sync: function() {
         let nItems = this._connectionItems.size;
         this._autoConnectItem.actor.visible = (nItems == 0);
-        this._deactivateItem.actor.visible = this._device.state > NetworkManager.DeviceState.DISCONNECTED;
+        this._deactivateItem.actor.visible = this._device.state > NM.DeviceState.DISCONNECTED;
+
+        if (this._activeConnection == null) {
+            this._activeConnection = this._device.active_connection;
+
+            if (this._activeConnection) {
+                ensureActiveConnectionProps(this._activeConnection, this._client);
+                let item = this._connectionItems.get(this._activeConnection.connection.get_uuid());
+                item.setActiveConnection(this._activeConnection);
+            }
+        }
+
         this.parent();
     },
 
@@ -449,31 +438,31 @@ var NMConnectionDevice = new Lang.Class({
             return '';
 
         switch(this._device.state) {
-        case NetworkManager.DeviceState.DISCONNECTED:
+        case NM.DeviceState.DISCONNECTED:
             /* Translators: %s is a network identifier */
             return _("%s Off").format(this._getDescription());
-        case NetworkManager.DeviceState.ACTIVATED:
+        case NM.DeviceState.ACTIVATED:
             /* Translators: %s is a network identifier */
             return _("%s Connected").format(this._getDescription());
-        case NetworkManager.DeviceState.UNMANAGED:
+        case NM.DeviceState.UNMANAGED:
             /* Translators: this is for network devices that are physically present but are not
                under NetworkManager's control (and thus cannot be used in the menu);
                %s is a network identifier */
             return _("%s Unmanaged").format(this._getDescription());
-        case NetworkManager.DeviceState.DEACTIVATING:
+        case NM.DeviceState.DEACTIVATING:
             /* Translators: %s is a network identifier */
             return _("%s Disconnecting").format(this._getDescription());
-        case NetworkManager.DeviceState.PREPARE:
-        case NetworkManager.DeviceState.CONFIG:
-        case NetworkManager.DeviceState.IP_CONFIG:
-        case NetworkManager.DeviceState.IP_CHECK:
-        case NetworkManager.DeviceState.SECONDARIES:
+        case NM.DeviceState.PREPARE:
+        case NM.DeviceState.CONFIG:
+        case NM.DeviceState.IP_CONFIG:
+        case NM.DeviceState.IP_CHECK:
+        case NM.DeviceState.SECONDARIES:
             /* Translators: %s is a network identifier */
             return _("%s Connecting").format(this._getDescription());
-        case NetworkManager.DeviceState.NEED_AUTH:
+        case NM.DeviceState.NEED_AUTH:
             /* Translators: this is for network connections that require some kind of key or password; %s is a network identifier */
             return _("%s Requires Authentication").format(this._getDescription());
-        case NetworkManager.DeviceState.UNAVAILABLE:
+        case NM.DeviceState.UNAVAILABLE:
             // This state is actually a compound of various states (generically unavailable,
             // firmware missing), that are exposed by different properties (whose state may
             // or may not updated when we receive state-changed).
@@ -485,7 +474,7 @@ var NMConnectionDevice = new Lang.Class({
             /* Translators: this is for a network device that cannot be activated (for example it
                is disabled by rfkill, or it has no coverage; %s is a network identifier */
             return _("%s Unavailable").format(this._getDescription());
-        case NetworkManager.DeviceState.FAILED:
+        case NM.DeviceState.FAILED:
             /* Translators: %s is a network identifier */
             return _("%s Connection Failed").format(this._getDescription());
         default:
@@ -500,14 +489,14 @@ var NMDeviceWired = new Lang.Class({
     Extends: NMConnectionDevice,
     category: NMConnectionCategory.WIRED,
 
-    _init: function(client, device, settings) {
-        this.parent(client, device, settings);
+    _init: function(client, device) {
+        this.parent(client, device);
 
         this.item.menu.addSettingsAction(_("Wired Settings"), 'gnome-network-panel.desktop');
     },
 
     _hasCarrier: function() {
-        if (this._device instanceof NMClient.DeviceEthernet)
+        if (this._device instanceof NM.DeviceEthernet)
             return this._device.carrier;
         else
             return true;
@@ -522,9 +511,9 @@ var NMDeviceWired = new Lang.Class({
         if (this._device.active_connection) {
             let state = this._device.active_connection.state;
 
-            if (state == NetworkManager.ActiveConnectionState.ACTIVATING) {
+            if (state == NM.ActiveConnectionState.ACTIVATING) {
                 return 'network-wired-acquiring-symbolic';
-            } else if (state == NetworkManager.ActiveConnectionState.ACTIVATED) {
+            } else if (state == NM.ActiveConnectionState.ACTIVATED) {
                 if (this._canReachInternet())
                     return 'network-wired-symbolic';
                 else
@@ -542,8 +531,8 @@ var NMDeviceModem = new Lang.Class({
     Extends: NMConnectionDevice,
     category: NMConnectionCategory.WWAN,
 
-    _init: function(client, device, settings) {
-        this.parent(client, device, settings);
+    _init: function(client, device) {
+        this.parent(client, device);
 
         this.item.menu.addSettingsAction(_("Mobile Broadband Settings"), 'gnome-network-panel.desktop');
 
@@ -552,11 +541,11 @@ var NMDeviceModem = new Lang.Class({
         let capabilities = device.current_capabilities;
         if (device.udi.indexOf('/org/freedesktop/ModemManager1/Modem') == 0)
             this._mobileDevice = new ModemManager.BroadbandModem(device.udi, capabilities);
-        else if (capabilities & NetworkManager.DeviceModemCapabilities.GSM_UMTS)
+        else if (capabilities & NM.DeviceModemCapabilities.GSM_UMTS)
             this._mobileDevice = new ModemManager.ModemGsm(device.udi);
-        else if (capabilities & NetworkManager.DeviceModemCapabilities.CDMA_EVDO)
+        else if (capabilities & NM.DeviceModemCapabilities.CDMA_EVDO)
             this._mobileDevice = new ModemManager.ModemCdma(device.udi);
-        else if (capabilities & NetworkManager.DeviceModemCapabilities.LTE)
+        else if (capabilities & NM.DeviceModemCapabilities.LTE)
             this._mobileDevice = new ModemManager.ModemGsm(device.udi);
 
         if (this._mobileDevice) {
@@ -593,7 +582,7 @@ var NMDeviceModem = new Lang.Class({
             /* Translators: this is for a network device that cannot be activated
                because it's disabled by rfkill (airplane mode); %s is a network identifier */
             return _("%s Disabled").format(this._getDescription());
-        else if (this._device.state == NetworkManager.DeviceState.ACTIVATED &&
+        else if (this._device.state == NM.DeviceState.ACTIVATED &&
                  this._mobileDevice && this._mobileDevice.operator_name)
             return this._mobileDevice.operator_name;
         else
@@ -602,7 +591,7 @@ var NMDeviceModem = new Lang.Class({
 
     getIndicatorIcon: function() {
         if (this._device.active_connection) {
-            if (this._device.active_connection.state == NetworkManager.ActiveConnectionState.ACTIVATING)
+            if (this._device.active_connection.state == NM.ActiveConnectionState.ACTIVATING)
                 return 'network-cellular-acquiring-symbolic';
 
             return this._getSignalIcon();
@@ -621,8 +610,8 @@ var NMDeviceBluetooth = new Lang.Class({
     Extends: NMConnectionDevice,
     category: NMConnectionCategory.WWAN,
 
-    _init: function(client, device, settings) {
-        this.parent(client, device, settings);
+    _init: function(client, device) {
+        this.parent(client, device);
 
         this.item.menu.addSettingsAction(_("Bluetooth Settings"), 'gnome-network-panel.desktop');
     },
@@ -638,9 +627,9 @@ var NMDeviceBluetooth = new Lang.Class({
     getIndicatorIcon: function() {
         if (this._device.active_connection) {
             let state = this._device.active_connection.state;
-            if (state == NetworkManager.ActiveConnectionState.ACTIVATING)
+            if (state == NM.ActiveConnectionState.ACTIVATING)
                 return 'network-cellular-acquiring-symbolic';
-            else if (state == NetworkManager.ActiveConnectionState.ACTIVATED)
+            else if (state == NM.ActiveConnectionState.ACTIVATED)
                 return 'network-cellular-connected-symbolic';
             else
                 return 'network-cellular-signal-none-symbolic';
@@ -719,7 +708,7 @@ var NMWirelessDialog = new Lang.Class({
     Name: 'NMWirelessDialog',
     Extends: ModalDialog.ModalDialog,
 
-    _init: function(client, device, settings) {
+    _init: function(client, device) {
         this.parent({ styleClass: 'nm-dialog' });
 
         this._client = client;
@@ -735,7 +724,7 @@ var NMWirelessDialog = new Lang.Class({
         this._networks = [];
         this._buildLayout();
 
-        let connections = settings.list_connections();
+        let connections = client.get_connections();
         this._connections = connections.filter(Lang.bind(this, function(connection) {
             return device.connection_valid(connection);
         }));
@@ -799,7 +788,7 @@ var NMWirelessDialog = new Lang.Class({
     },
 
     _onScanTimeout: function() {
-        this._device.request_scan_simple(null);
+        this._device.request_scan_async(null, null);
         return GLib.SOURCE_CONTINUE;
     },
 
@@ -944,7 +933,7 @@ var NMWirelessDialog = new Lang.Class({
         let network = this._selectedNetwork;
         if (network.connections.length > 0) {
             let connection = network.connections[0];
-            this._client.activate_connection(connection, this._device, null, null);
+            this._client.activate_connection_async(connection, this._device, null, null, null);
         } else {
             let accessPoints = network.accessPoints;
             if ((accessPoints[0]._secType == NMAccessPointSecurity.WPA2_ENT)
@@ -952,10 +941,10 @@ var NMWirelessDialog = new Lang.Class({
                 // 802.1x-enabled APs require further configuration, so they're
                 // handled in gnome-control-center
                 Util.spawn(['gnome-control-center', 'wifi', 'connect-8021x-wifi',
-                            this._device.get_path(), accessPoints[0].dbus_path]);
+                            this._device.get_path(), accessPoints[0].path]);
             } else {
-                let connection = new NetworkManager.Connection();
-                this._client.add_and_activate_connection(connection, this._device, accessPoints[0].dbus_path, null)
+                let connection = new NM.SimpleConnection();
+                this._client.add_and_activate_connection_async(connection, this._device, accessPoints[0].path, null, null)
             }
         }
 
@@ -1035,7 +1024,7 @@ var NMWirelessDialog = new Lang.Class({
     },
 
     _networkCompare: function(network, accessPoint) {
-        if (!ssidCompare(network.ssid, accessPoint.get_ssid()))
+        if (!network.ssid.equal (accessPoint.get_ssid()))
             return false;
         if (network.mode != accessPoint.mode)
             return false;
@@ -1180,10 +1169,9 @@ var NMDeviceWireless = new Lang.Class({
     Name: 'NMDeviceWireless',
     category: NMConnectionCategory.WIRELESS,
 
-    _init: function(client, device, settings) {
+    _init: function(client, device) {
         this._client = client;
         this._device = device;
-        this._settings = settings;
 
         this._description = '';
 
@@ -1252,8 +1240,8 @@ var NMDeviceWireless = new Lang.Class({
         /* Emit a notification if activation fails, but don't do it
            if the reason is no secrets, as that indicates the user
            cancelled the agent dialog */
-        if (newstate == NetworkManager.DeviceState.FAILED &&
-            reason != NetworkManager.DeviceStateReason.NO_SECRETS) {
+        if (newstate == NM.DeviceState.FAILED &&
+            reason != NM.DeviceStateReason.NO_SECRETS) {
             this.emit('activation-failed', reason);
         }
 
@@ -1265,7 +1253,7 @@ var NMDeviceWireless = new Lang.Class({
     },
 
     _showDialog: function() {
-        this._dialog = new NMWirelessDialog(this._client, this._device, this._settings);
+        this._dialog = new NMWirelessDialog(this._client, this._device);
         this._dialog.connect('closed', Lang.bind(this, this._dialogClosed));
         this._dialog.open();
     },
@@ -1314,8 +1302,8 @@ var NMDeviceWireless = new Lang.Class({
         if (this._isHotSpotMaster())
             /* Translators: %s is a network identifier */
             return _("%s Hotspot Active").format(this._description);
-        else if (this._device.state >= NetworkManager.DeviceState.PREPARE &&
-                 this._device.state < NetworkManager.DeviceState.ACTIVATED)
+        else if (this._device.state >= NM.DeviceState.PREPARE &&
+                 this._device.state < NM.DeviceState.ACTIVATED)
             /* Translators: %s is a network identifier */
             return _("%s Connecting").format(this._description);
         else if (ap)
@@ -1326,7 +1314,7 @@ var NMDeviceWireless = new Lang.Class({
         else if (!this._client.wireless_enabled)
             /* Translators: %s is a network identifier */
             return _("%s Off").format(this._description);
-        else if (this._device.state == NetworkManager.DeviceState.DISCONNECTED)
+        else if (this._device.state == NM.DeviceState.DISCONNECTED)
             /* Translators: %s is a network identifier */
             return _("%s Not Connected").format(this._description);
         else
@@ -1344,18 +1332,14 @@ var NMDeviceWireless = new Lang.Class({
         if (this._client.primary_connection != this._device.active_connection)
             return true;
 
-        return this._client.connectivity == NetworkManager.ConnectivityState.FULL;
+        return this._client.connectivity == NM.ConnectivityState.FULL;
     },
 
     _isHotSpotMaster: function() {
         if (!this._device.active_connection)
             return false;
 
-        let connectionPath = this._device.active_connection.connection;
-        if (!connectionPath)
-            return false;
-
-        let connection = this._settings.get_connection_by_path(connectionPath);
+        let connection = this._device.active_connection.connection;
         if (!connection)
             return false;
 
@@ -1363,13 +1347,13 @@ var NMDeviceWireless = new Lang.Class({
         if (!ip4config)
             return false;
 
-        return ip4config.get_method() == NetworkManager.SETTING_IP4_CONFIG_METHOD_SHARED;
+        return ip4config.get_method() == NM.SETTING_IP4_CONFIG_METHOD_SHARED;
     },
 
     getIndicatorIcon: function() {
-        if (this._device.state < NetworkManager.DeviceState.PREPARE)
+        if (this._device.state < NM.DeviceState.PREPARE)
             return 'network-wireless-disconnected-symbolic';
-        if (this._device.state < NetworkManager.DeviceState.ACTIVATED)
+        if (this._device.state < NM.DeviceState.ACTIVATED)
             return 'network-wireless-acquiring-symbolic';
 
         if (this._isHotSpotMaster())
@@ -1394,15 +1378,15 @@ var NMDeviceWireless = new Lang.Class({
 });
 Signals.addSignalMethods(NMDeviceWireless.prototype);
 
-var NMVPNConnectionItem = new Lang.Class({
-    Name: 'NMVPNConnectionItem',
+var NMVpnConnectionItem = new Lang.Class({
+    Name: 'NMVpnConnectionItem',
     Extends: NMConnectionItem,
 
     isActive: function() {
         if (this._activeConnection == null)
             return false;
 
-        return this._activeConnection.vpn_state != NetworkManager.VPNConnectionState.DISCONNECTED;
+        return this._activeConnection.vpn_state != NM.VpnConnectionState.DISCONNECTED;
     },
 
     _buildUI: function() {
@@ -1426,17 +1410,17 @@ var NMVPNConnectionItem = new Lang.Class({
             return null;
 
         switch(this._activeConnection.vpn_state) {
-        case NetworkManager.VPNConnectionState.DISCONNECTED:
-        case NetworkManager.VPNConnectionState.ACTIVATED:
+        case NM.VpnConnectionState.DISCONNECTED:
+        case NM.VpnConnectionState.ACTIVATED:
             return null;
-        case NetworkManager.VPNConnectionState.PREPARE:
-        case NetworkManager.VPNConnectionState.CONNECT:
-        case NetworkManager.VPNConnectionState.IP_CONFIG_GET:
+        case NM.VpnConnectionState.PREPARE:
+        case NM.VpnConnectionState.CONNECT:
+        case NM.VpnConnectionState.IP_CONFIG_GET:
             return _("connecting…");
-        case NetworkManager.VPNConnectionState.NEED_AUTH:
+        case NM.VpnConnectionState.NEED_AUTH:
             /* Translators: this is for network connections that require some kind of key or password */
             return _("authentication required");
-        case NetworkManager.VPNConnectionState.FAILED:
+        case NM.VpnConnectionState.FAILED:
             return _("connection failed");
         default:
             return 'invalid';
@@ -1444,11 +1428,11 @@ var NMVPNConnectionItem = new Lang.Class({
     },
 
     _connectionStateChanged: function(ac, newstate, reason) {
-        if (newstate == NetworkManager.VPNConnectionState.FAILED &&
-            reason != NetworkManager.VPNConnectionStateReason.NO_SECRETS) {
+        if (newstate == NM.VpnConnectionState.FAILED &&
+            reason != NM.VpnConnectionStateReason.NO_SECRETS) {
             // FIXME: if we ever want to show something based on reason,
-            // we need to convert from NetworkManager.VPNConnectionStateReason
-            // to NetworkManager.DeviceStateReason
+            // we need to convert from NM.VpnConnectionStateReason
+            // to NM.DeviceStateReason
             this.emit('activation-failed', reason);
         }
 
@@ -1473,7 +1457,7 @@ var NMVPNConnectionItem = new Lang.Class({
 
     getIndicatorIcon: function() {
         if (this._activeConnection) {
-            if (this._activeConnection.vpn_state < NetworkManager.VPNConnectionState.ACTIVATED)
+            if (this._activeConnection.vpn_state < NM.VpnConnectionState.ACTIVATED)
                 return 'network-vpn-acquiring-symbolic';
             else
                 return 'network-vpn-symbolic';
@@ -1483,8 +1467,8 @@ var NMVPNConnectionItem = new Lang.Class({
     },
 });
 
-var NMVPNSection = new Lang.Class({
-    Name: 'NMVPNSection',
+var NMVpnSection = new Lang.Class({
+    Name: 'NMVpnSection',
     Extends: NMConnectionSection,
     category: NMConnectionCategory.VPN,
 
@@ -1513,11 +1497,11 @@ var NMVPNSection = new Lang.Class({
     },
 
     activateConnection: function(connection) {
-        this._client.activate_connection(connection, null, null, null);
+        this._client.activate_connection_async(connection, null, null, null, null);
     },
 
     deactivateConnection: function(activeConnection) {
-        this._client.deactivate_connection(activeConnection);
+        this._client.deactivate_connection(activeConnection, null);
     },
 
     setActiveConnections: function(vpnConnections) {
@@ -1526,15 +1510,15 @@ var NMVPNSection = new Lang.Class({
             item.setActiveConnection(null);
         }
         vpnConnections.forEach(Lang.bind(this, function(a) {
-            if (a._connection) {
-                let item = this._connectionItems.get(a._connection.get_uuid());
+            if (a.connection) {
+                let item = this._connectionItems.get(a.connection.get_uuid());
                 item.setActiveConnection(a);
             }
         }));
     },
 
     _makeConnectionItem: function(connection) {
-        return new NMVPNConnectionItem(this, connection);
+        return new NMVpnConnectionItem(this, connection);
     },
 
     getIndicatorIcon: function() {
@@ -1547,7 +1531,7 @@ var NMVPNSection = new Lang.Class({
         return '';
     },
 });
-Signals.addSignalMethods(NMVPNSection.prototype);
+Signals.addSignalMethods(NMVpnSection.prototype);
 
 var DeviceCategory = new Lang.Class({
     Name: 'DeviceCategory',
@@ -1628,40 +1612,25 @@ var NMApplet = new Lang.Class({
 
         // Device types
         this._dtypes = { };
-        this._dtypes[NetworkManager.DeviceType.ETHERNET] = NMDeviceWired;
-        this._dtypes[NetworkManager.DeviceType.WIFI] = NMDeviceWireless;
-        this._dtypes[NetworkManager.DeviceType.MODEM] = NMDeviceModem;
-        this._dtypes[NetworkManager.DeviceType.BT] = NMDeviceBluetooth;
-        // TODO: WiMax support
+        this._dtypes[NM.DeviceType.ETHERNET] = NMDeviceWired;
+        this._dtypes[NM.DeviceType.WIFI] = NMDeviceWireless;
+        this._dtypes[NM.DeviceType.MODEM] = NMDeviceModem;
+        this._dtypes[NM.DeviceType.BT] = NMDeviceBluetooth;
 
         // Connection types
         this._ctypes = { };
-        this._ctypes[NetworkManager.SETTING_WIRED_SETTING_NAME] = NMConnectionCategory.WIRED;
-        this._ctypes[NetworkManager.SETTING_WIRELESS_SETTING_NAME] = NMConnectionCategory.WIRELESS;
-        this._ctypes[NetworkManager.SETTING_BLUETOOTH_SETTING_NAME] = NMConnectionCategory.WWAN;
-        this._ctypes[NetworkManager.SETTING_CDMA_SETTING_NAME] = NMConnectionCategory.WWAN;
-        this._ctypes[NetworkManager.SETTING_GSM_SETTING_NAME] = NMConnectionCategory.WWAN;
-        this._ctypes[NetworkManager.SETTING_VPN_SETTING_NAME] = NMConnectionCategory.VPN;
+        this._ctypes[NM.SETTING_WIRED_SETTING_NAME] = NMConnectionCategory.WIRED;
+        this._ctypes[NM.SETTING_WIRELESS_SETTING_NAME] = NMConnectionCategory.WIRELESS;
+        this._ctypes[NM.SETTING_BLUETOOTH_SETTING_NAME] = NMConnectionCategory.WWAN;
+        this._ctypes[NM.SETTING_CDMA_SETTING_NAME] = NMConnectionCategory.WWAN;
+        this._ctypes[NM.SETTING_GSM_SETTING_NAME] = NMConnectionCategory.WWAN;
+        this._ctypes[NM.SETTING_VPN_SETTING_NAME] = NMConnectionCategory.VPN;
 
-        NMClient.Client.new_async(null, Lang.bind(this, this._clientGot));
-        NMClient.RemoteSettings.new_async(null, null, Lang.bind(this, this._remoteSettingsGot));
+        NM.Client.new_async(null, Lang.bind(this, this._clientGot));
     },
 
     _clientGot: function(obj, result) {
-        this._client = NMClient.Client.new_finish(result);
-
-        this._tryLateInit();
-    },
-
-    _remoteSettingsGot: function(obj, result) {
-        this._settings = NMClient.RemoteSettings.new_finish(result);
-
-        this._tryLateInit();
-    },
-
-    _tryLateInit: function() {
-        if (!this._client || !this._settings)
-            return;
+        this._client = NM.Client.new_finish(result);
 
         this._activeConnections = [ ];
         this._connections = [ ];
@@ -1684,7 +1653,7 @@ var NMApplet = new Lang.Class({
             this.menu.addMenuItem(this._devices[category]);
         }
 
-        this._vpnSection = new NMVPNSection(this._client);
+        this._vpnSection = new NMVpnSection(this._client);
         this._vpnSection.connect('activation-failed', Lang.bind(this, this._onActivationFailed));
         this._vpnSection.connect('icon-changed', Lang.bind(this, this._updateIcon));
         this.menu.addMenuItem(this._vpnSection.item);
@@ -1693,18 +1662,19 @@ var NMApplet = new Lang.Class({
         this._readDevices();
         this._syncNMState();
         this._syncMainConnection();
-        this._syncVPNConnections();
+        this._syncVpnConnections();
 
-        this._client.connect('notify::manager-running', Lang.bind(this, this._syncNMState));
+        this._client.connect('notify::nm-running', Lang.bind(this, this._syncNMState));
         this._client.connect('notify::networking-enabled', Lang.bind(this, this._syncNMState));
         this._client.connect('notify::state', Lang.bind(this, this._syncNMState));
         this._client.connect('notify::primary-connection', Lang.bind(this, this._syncMainConnection));
         this._client.connect('notify::activating-connection', Lang.bind(this, this._syncMainConnection));
-        this._client.connect('notify::active-connections', Lang.bind(this, this._syncVPNConnections));
+        this._client.connect('notify::active-connections', Lang.bind(this, this._syncVpnConnections));
         this._client.connect('notify::connectivity', Lang.bind(this, this._syncConnectivity));
         this._client.connect('device-added', Lang.bind(this, this._deviceAdded));
         this._client.connect('device-removed', Lang.bind(this, this._deviceRemoved));
-        this._settings.connect('new-connection', Lang.bind(this, this._newConnection));
+        this._client.connect('connection-added', Lang.bind(this, this._connectionAdded));
+        this._client.connect('connection-removed', Lang.bind(this, this._connectionRemoved));
 
         Main.sessionMode.connect('updated', Lang.bind(this, this._sessionUpdated));
         this._sessionUpdated();
@@ -1762,7 +1732,7 @@ var NMApplet = new Lang.Class({
     },
 
     _syncDeviceNames: function() {
-        let names = NMGtk.utils_disambiguate_device_names(this._nmDevices);
+        let names = NM.Device.disambiguate_names(this._nmDevices);
         for (let i = 0; i < this._nmDevices.length; i++) {
             let device = this._nmDevices[i];
             let description = names[i];
@@ -1779,7 +1749,7 @@ var NMApplet = new Lang.Class({
 
         let wrapperClass = this._dtypes[device.get_device_type()];
         if (wrapperClass) {
-            let wrapper = new wrapperClass(this._client, device, this._settings);
+            let wrapper = new wrapperClass(this._client, device);
             device._delegate = wrapper;
             this._addDeviceWrapper(wrapper);
 
@@ -1836,13 +1806,13 @@ var NMApplet = new Lang.Class({
 
         connection = this._client.get_primary_connection();
         if (connection) {
-            ensureActiveConnectionProps(connection, this._settings);
+            ensureActiveConnectionProps(connection, this._client);
             return connection;
         }
 
         connection = this._client.get_activating_connection();
         if (connection) {
-            ensureActiveConnectionProps(connection, this._settings);
+            ensureActiveConnectionProps(connection, this._client);
             return connection;
         }
 
@@ -1873,13 +1843,13 @@ var NMApplet = new Lang.Class({
         this._syncConnectivity();
     },
 
-    _syncVPNConnections: function() {
+    _syncVpnConnections: function() {
         let activeConnections = this._client.get_active_connections() || [];
         let vpnConnections = activeConnections.filter(function(a) {
-            return (a instanceof NMClient.VPNConnection);
+            return (a instanceof NM.VpnConnection);
         });
         vpnConnections.forEach(Lang.bind(this, function(a) {
-            ensureActiveConnectionProps(a, this._settings);
+            ensureActiveConnectionProps(a, this._client);
         }));
         this._vpnSection.setActiveConnections(vpnConnections);
 
@@ -1887,7 +1857,7 @@ var NMApplet = new Lang.Class({
     },
 
     _mainConnectionStateChanged: function() {
-        if (this._mainConnection.state == NetworkManager.ActiveConnectionState.ACTIVATED && this._notification)
+        if (this._mainConnection.state == NM.ActiveConnectionState.ACTIVATED && this._notification)
             this._notification.destroy();
     },
 
@@ -1911,23 +1881,22 @@ var NMApplet = new Lang.Class({
             return;
         }
 
-        connection._removedId = connection.connect('removed', Lang.bind(this, this._connectionRemoved));
-        connection._updatedId = connection.connect('updated', Lang.bind(this, this._updateConnection));
+        connection._updatedId = connection.connect('changed', Lang.bind(this, this._updateConnection));
 
         this._updateConnection(connection);
         this._connections.push(connection);
     },
 
     _readConnections: function() {
-        let connections = this._settings.list_connections();
+        let connections = this._client.get_connections();
         connections.forEach(Lang.bind(this, this._addConnection));
     },
 
-    _newConnection: function(settings, connection) {
+    _connectionAdded: function(client, connection) {
         this._addConnection(connection);
     },
 
-    _connectionRemoved: function(connection) {
+    _connectionRemoved: function(client, connection) {
         let pos = this._connections.indexOf(connection);
         if (pos != -1)
             this._connections.splice(pos, 1);
@@ -1947,13 +1916,12 @@ var NMApplet = new Lang.Class({
             }
         }
 
-        connection.disconnect(connection._removedId);
         connection.disconnect(connection._updatedId);
-        connection._removedId = connection._updatedId = 0;
+        connection._updatedId = 0;
     },
 
     _updateConnection: function(connection) {
-        let connectionSettings = connection.get_setting_by_name(NetworkManager.SETTING_CONNECTION_SETTING_NAME);
+        let connectionSettings = connection.get_setting_by_name(NM.SETTING_CONNECTION_SETTING_NAME);
         connection._type = connectionSettings.type;
         connection._section = this._ctypes[connection._type] || NMConnectionCategory.INVALID;
 
@@ -1974,7 +1942,7 @@ var NMApplet = new Lang.Class({
     },
 
     _syncNMState: function() {
-        this.indicators.visible = this._client.manager_running;
+        this.indicators.visible = this._client.nm_running;
         this.menu.actor.visible = this._client.networking_enabled;
 
         this._syncConnectivity();
@@ -2015,7 +1983,7 @@ var NMApplet = new Lang.Class({
             this._client.check_connectivity_async(null, Lang.bind(this, function(client, result) {
                 try {
                     let state = client.check_connectivity_finish(result);
-                    if (state >= NetworkManager.ConnectivityState.FULL)
+                    if (state >= NM.ConnectivityState.FULL)
                         this._closeConnectivityCheck(path);
                 } catch(e) { }
             }));
@@ -2026,19 +1994,19 @@ var NMApplet = new Lang.Class({
 
     _syncConnectivity: function() {
         if (this._mainConnection == null ||
-            this._mainConnection.state != NetworkManager.ActiveConnectionState.ACTIVATED) {
+            this._mainConnection.state != NM.ActiveConnectionState.ACTIVATED) {
             this._flushConnectivityQueue();
             return;
         }
 
-        let isPortal = this._client.connectivity == NetworkManager.ConnectivityState.PORTAL;
+        let isPortal = this._client.connectivity == NM.ConnectivityState.PORTAL;
         // For testing, allow interpreting any value != FULL as PORTAL, because
         // LIMITED (no upstream route after the default gateway) is easy to obtain
         // with a tethered phone
         // NONE is also possible, with a connection configured to force no default route
         // (but in general we should only prompt a portal if we know there is a portal)
         if (GLib.getenv('GNOME_SHELL_CONNECTIVITY_TEST') != null)
-            isPortal = isPortal || this._client.connectivity < NetworkManager.ConnectivityState.FULL;
+            isPortal = isPortal || this._client.connectivity < NM.ConnectivityState.FULL;
         if (!isPortal || Main.sessionMode.isGreeter)
             return;
 
@@ -2078,12 +2046,12 @@ var NMApplet = new Lang.Class({
                 dev = this._mainConnection._primaryDevice;
 
             let state = this._client.get_state();
-            let connected = state == NetworkManager.State.CONNECTED_GLOBAL;
+            let connected = state == NM.State.CONNECTED_GLOBAL;
             this._primaryIndicator.visible = (dev != null) || connected;
             if (dev) {
                 this._primaryIndicator.icon_name = dev.getIndicatorIcon();
             } else if (connected) {
-                if (this._client.connectivity == NetworkManager.ConnectivityState.FULL)
+                if (this._client.connectivity == NM.ConnectivityState.FULL)
                     this._primaryIndicator.icon_name = 'network-wired-symbolic';
                 else
                     this._primaryIndicator.icon_name = 'network-wired-no-route-symbolic';
diff --git a/meson.build b/meson.build
index b82c413..caaae53 100644
--- a/meson.build
+++ b/meson.build
@@ -106,13 +106,7 @@ enable_networkmanager = get_option('enable-networkmanager')
 if enable_networkmanager != 'no'
   want_networkmanager = enable_networkmanager == 'yes'
 
-  nm_deps += dependency('libnm-glib',
-    version: nm_req, required: want_networkmanager
-  )
-  nm_deps += dependency('libnm-util',
-    version: nm_req, required: want_networkmanager
-  )
-  nm_deps += dependency('libnm-gtk',
+  nm_deps += dependency('libnm',
     version: nm_req, required: want_networkmanager
   )
   nm_deps += dependency('libsecret-1',
diff --git a/src/meson.build b/src/meson.build
index 3e55573..f309552 100644
--- a/src/meson.build
+++ b/src/meson.build
@@ -227,7 +227,7 @@ libshell_gir_includes = [
 ]
 
 if have_networkmanager
-  libshell_gir_includes += ['NetworkManager-1.0', 'NMClient-1.0']
+  libshell_gir_includes += ['NM-1.0']
 endif
 
 libshell_gir_includes += [
diff --git a/src/shell-network-agent.c b/src/shell-network-agent.c
index 4862b6d..8e1f820 100644
--- a/src/shell-network-agent.c
+++ b/src/shell-network-agent.c
@@ -2,6 +2,7 @@
 /*
  * Copyright 2011 Red Hat, Inc.
  *           2011 Giovanni Campagna <scampa.giovanni@gmail.com>
+ *           2017 Lubomir Rintel <lkundrak@v3.sk>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -21,7 +22,6 @@
 
 #include "config.h"
 #include <string.h>
-#include <dbus/dbus-glib.h>
 
 #include <libsecret/secret.h>
 
@@ -36,21 +36,18 @@ enum {
 static gint signals[SIGNAL_LAST];
 
 typedef struct {
-  GCancellable *                 cancellable;
-  ShellNetworkAgent             *self;
-
-  gchar                         *request_id;
-  NMConnection                  *connection;
-  gchar                         *setting_name;
-  gchar                        **hints;
-  NMSecretAgentGetSecretsFlags   flags;
-  NMSecretAgentGetSecretsFunc    callback;
-  gpointer                       callback_data;
-
-  /* <gchar *setting_key, gchar *secret> */
-  GHashTable                    *entries;
-  GHashTable                    *vpn_entries;
-  gboolean                       is_vpn;
+  GCancellable *                    cancellable;
+  ShellNetworkAgent                *self;
+
+  gchar                            *request_id;
+  NMConnection                     *connection;
+  gchar                            *setting_name;
+  gchar                           **hints;
+  NMSecretAgentGetSecretsFlags      flags;
+  NMSecretAgentOldGetSecretsFunc    callback;
+  gpointer                          callback_data;
+
+  GVariantDict                     *entries;
 } ShellAgentRequest;
 
 struct _ShellNetworkAgentPrivate {
@@ -58,7 +55,7 @@ struct _ShellNetworkAgentPrivate {
   GHashTable *requests;
 };
 
-G_DEFINE_TYPE_WITH_PRIVATE (ShellNetworkAgent, shell_network_agent, NM_TYPE_SECRET_AGENT)
+G_DEFINE_TYPE_WITH_PRIVATE (ShellNetworkAgent, shell_network_agent, NM_TYPE_SECRET_AGENT_OLD)
 
 static const SecretSchema network_agent_schema = {
     "org.freedesktop.NetworkManager.Connection",
@@ -82,7 +79,7 @@ shell_agent_request_free (gpointer data)
   g_object_unref (request->connection);
   g_free (request->setting_name);
   g_strfreev (request->hints);
-  g_hash_table_destroy (request->entries);
+  g_clear_pointer (&request->entries, g_variant_dict_unref);
 
   g_slice_free (ShellAgentRequest, request);
 }
@@ -98,7 +95,7 @@ shell_agent_request_cancel (ShellAgentRequest *request)
   error = g_error_new (NM_SECRET_AGENT_ERROR,
                        NM_SECRET_AGENT_ERROR_AGENT_CANCELED,
                        "Canceled by NetworkManager");
-  request->callback (NM_SECRET_AGENT (self), request->connection,
+  request->callback (NM_SECRET_AGENT_OLD (self), request->connection,
                      NULL, error, request->callback_data);
 
   g_signal_emit (self, signals[SIGNAL_CANCEL_REQUEST], 0, request->request_id);
@@ -135,7 +132,7 @@ shell_network_agent_finalize (GObject *object)
     {
       ShellAgentRequest *request = value;
 
-      request->callback (NM_SECRET_AGENT (object),
+      request->callback (NM_SECRET_AGENT_OLD (object),
                          request->connection,
                          NULL, error,
                          request->callback_data);
@@ -232,14 +229,6 @@ is_connection_always_ask (NMConnection *connection)
   return FALSE;
 }
 
-static void
-gvalue_destroy_notify (gpointer data)
-{
-  GValue *value = data;
-  g_value_unset (value);
-  g_slice_free (GValue, value);
-}
-
 static void
 get_secrets_keyring_cb (GObject            *source,
                         GAsyncResult       *result,
@@ -252,8 +241,9 @@ get_secrets_keyring_cb (GObject            *source,
   GError *error = NULL;
   GList *items;
   GList *l;
-  GHashTable *outer;
   gboolean secrets_found = FALSE;
+  GVariantBuilder builder_setting, builder_connection;
+  GVariant *setting;
 
   items = secret_service_search_finish (NULL, result, &secret_error);
 
@@ -271,14 +261,16 @@ get_secrets_keyring_cb (GObject            *source,
     {
       g_set_error (&error,
                    NM_SECRET_AGENT_ERROR,
-                   NM_SECRET_AGENT_ERROR_INTERNAL_ERROR,
+                   NM_SECRET_AGENT_ERROR_FAILED,
                    "Internal error while retrieving secrets from the keyring (%s)", secret_error->message);
       g_error_free (secret_error);
-      closure->callback (NM_SECRET_AGENT (closure->self), closure->connection, NULL, error, closure->callback_data);
+      closure->callback (NM_SECRET_AGENT_OLD (closure->self), closure->connection, NULL, error, closure->callback_data);
 
       goto out;
     }
 
+  g_variant_builder_init (&builder_setting, NM_VARIANT_TYPE_SETTING);
+
   for (l = items; l; l = g_list_next (l))
     {
       SecretItem *item = l->data;
@@ -297,18 +289,8 @@ get_secrets_keyring_cb (GObject            *source,
         {
           if (g_strcmp0 (name, SHELL_KEYRING_SK_TAG) == 0)
             {
-              gchar *secret_name = g_strdup (attribute);
-
-              if (!closure->is_vpn)
-                {
-                  GValue *secret_value = g_slice_new0 (GValue);
-                  g_value_init (secret_value, G_TYPE_STRING);
-                  g_value_set_string (secret_value, secret_value_get (secret, NULL));
-
-                  g_hash_table_insert (closure->entries, secret_name, secret_value);
-                }
-              else
-                g_hash_table_insert (closure->vpn_entries, secret_name, g_strdup (secret_value_get (secret, NULL)));
+              g_variant_builder_add (&builder_setting, "{sv}", attribute,
+                                     g_variant_new_string (secret_value_get (secret, NULL)));
 
               secrets_found = TRUE;
 
@@ -321,6 +303,7 @@ get_secrets_keyring_cb (GObject            *source,
     }
 
   g_list_free_full (items, g_object_unref);
+  setting = g_variant_builder_end (&builder_setting);
 
   /* All VPN requests get sent to the VPN's auth dialog, since it knows better
    * than the agent about what secrets are required.  Otherwise, if no secrets
@@ -328,21 +311,24 @@ get_secrets_keyring_cb (GObject            *source,
    * NetworkManager will fail the connection if not secrets are returned
    * instead of asking again with REQUEST_NEW.
    */
-  if (closure->is_vpn ||
+  if (strcmp(closure->setting_name, NM_SETTING_VPN_SETTING_NAME) == 0 ||
       (!secrets_found && (closure->flags & NM_SECRET_AGENT_GET_SECRETS_FLAG_ALLOW_INTERACTION)))
     {
-      nm_connection_update_secrets (closure->connection, closure->setting_name, closure->entries, NULL);
+      nm_connection_update_secrets (closure->connection, closure->setting_name,
+                                    setting, NULL);
 
+      closure->entries = g_variant_dict_new (setting);
       request_secrets_from_ui (closure);
       return;
     }
 
-  outer = g_hash_table_new (g_str_hash, g_str_equal);
-  g_hash_table_insert (outer, closure->setting_name, closure->entries);
-
-  closure->callback (NM_SECRET_AGENT (closure->self), closure->connection, outer, NULL, closure->callback_data);
+  g_variant_builder_init (&builder_connection, NM_VARIANT_TYPE_CONNECTION);
+  g_variant_builder_add (&builder_connection, "{s@a{sv}}",
+                         closure->setting_name, setting);
 
-  g_hash_table_destroy (outer);
+  closure->callback (NM_SECRET_AGENT_OLD (closure->self), closure->connection,
+                     g_variant_builder_end (&builder_connection), NULL,
+                     closure->callback_data);
 
  out:
   g_hash_table_remove (priv->requests, closure->request_id);
@@ -350,14 +336,14 @@ get_secrets_keyring_cb (GObject            *source,
 }
 
 static void
-shell_network_agent_get_secrets (NMSecretAgent                 *agent,
-				 NMConnection                  *connection,
-				 const gchar                   *connection_path,
-				 const gchar                   *setting_name,
-				 const gchar                  **hints,
-				 NMSecretAgentGetSecretsFlags   flags,
-				 NMSecretAgentGetSecretsFunc    callback,
-				 gpointer                       callback_data)
+shell_network_agent_get_secrets (NMSecretAgentOld                 *agent,
+				 NMConnection                     *connection,
+				 const gchar                      *connection_path,
+				 const gchar                      *setting_name,
+				 const gchar                     **hints,
+				 NMSecretAgentGetSecretsFlags      flags,
+				 NMSecretAgentOldGetSecretsFunc    callback,
+				 gpointer                          callback_data)
 {
   ShellNetworkAgent *self = SHELL_NETWORK_AGENT (agent);
   ShellAgentRequest *request;
@@ -374,7 +360,7 @@ shell_network_agent_get_secrets (NMSecretAgent                 *agent,
       shell_agent_request_cancel (request);
     }
 
-  request = g_slice_new (ShellAgentRequest);
+  request = g_slice_new0 (ShellAgentRequest);
   request->self = g_object_ref (self);
   request->cancellable = g_cancellable_new ();
   request->connection = g_object_ref (connection);
@@ -383,22 +369,6 @@ shell_network_agent_get_secrets (NMSecretAgent                 *agent,
   request->flags = flags;
   request->callback = callback;
   request->callback_data = callback_data;
-  request->is_vpn = !strcmp(setting_name, NM_SETTING_VPN_SETTING_NAME);
-  request->entries = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, gvalue_destroy_notify);
-
-  if (request->is_vpn)
-    {
-      GValue *secret_value;
-
-      request->vpn_entries = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
-
-      secret_value = g_slice_new0 (GValue);
-      g_value_init (secret_value, dbus_g_type_get_map ("GHashTable", G_TYPE_STRING, G_TYPE_STRING));
-      g_value_take_boxed (secret_value, request->vpn_entries);
-      g_hash_table_insert (request->entries, g_strdup(NM_SETTING_VPN_SECRETS), secret_value);
-    }
-  else
-    request->vpn_entries = NULL;
 
   request->request_id = request_id;
   g_hash_table_replace (self->priv->requests, request->request_id, request);
@@ -407,6 +377,7 @@ shell_network_agent_get_secrets (NMSecretAgent                 *agent,
       ((flags & NM_SECRET_AGENT_GET_SECRETS_FLAG_ALLOW_INTERACTION)
        && is_connection_always_ask (request->connection)))
     {
+      request->entries = g_variant_dict_new (NULL);
       request_secrets_from_ui (request);
       return;
     }
@@ -431,7 +402,6 @@ shell_network_agent_set_password (ShellNetworkAgent *self,
 {
   ShellNetworkAgentPrivate *priv;
   ShellAgentRequest *request;
-  GValue *value;
 
   g_return_if_fail (SHELL_IS_NETWORK_AGENT (self));
 
@@ -439,18 +409,7 @@ shell_network_agent_set_password (ShellNetworkAgent *self,
   request = g_hash_table_lookup (priv->requests, request_id);
   g_return_if_fail (request != NULL);
 
-  if (!request->is_vpn)
-    {
-      value = g_slice_new0 (GValue);
-      g_value_init (value, G_TYPE_STRING);
-      g_value_set_string (value, setting_value);
-
-      g_hash_table_replace (request->entries, g_strdup (setting_key), value);
-    }
-  else
-    {
-      g_hash_table_replace (request->vpn_entries, g_strdup (setting_key), g_strdup (setting_value));
-    }
+  g_variant_dict_insert (request->entries, setting_key, "s", setting_value);
 }
 
 void
@@ -460,7 +419,8 @@ shell_network_agent_respond (ShellNetworkAgent         *self,
 {
   ShellNetworkAgentPrivate *priv;
   ShellAgentRequest *request;
-  GHashTable *outer;
+  GVariantBuilder builder_connection;
+  GVariant *setting;
 
   g_return_if_fail (SHELL_IS_NETWORK_AGENT (self));
 
@@ -474,7 +434,7 @@ shell_network_agent_respond (ShellNetworkAgent         *self,
                                    NM_SECRET_AGENT_ERROR_USER_CANCELED,
                                    "Network dialog was canceled by the user");
 
-      request->callback (NM_SECRET_AGENT (self), request->connection, NULL, error, request->callback_data);
+      request->callback (NM_SECRET_AGENT_OLD (self), request->connection, NULL, error, request->callback_data);
       g_error_free (error);
       g_hash_table_remove (priv->requests, request_id);
       return;
@@ -483,10 +443,10 @@ shell_network_agent_respond (ShellNetworkAgent         *self,
   if (response == SHELL_NETWORK_AGENT_INTERNAL_ERROR)
     {
       GError *error = g_error_new (NM_SECRET_AGENT_ERROR,
-                                   NM_SECRET_AGENT_ERROR_INTERNAL_ERROR,
+                                   NM_SECRET_AGENT_ERROR_FAILED,
                                    "An internal error occurred while processing the request.");
 
-      request->callback (NM_SECRET_AGENT (self), request->connection, NULL, error, request->callback_data);
+      request->callback (NM_SECRET_AGENT_OLD (self), request->connection, NULL, error, request->callback_data);
       g_error_free (error);
       g_hash_table_remove (priv->requests, request_id);
       return;
@@ -494,30 +454,34 @@ shell_network_agent_respond (ShellNetworkAgent         *self,
 
   /* response == SHELL_NETWORK_AGENT_CONFIRMED */
 
+  setting = g_variant_dict_end (request->entries);
+
   /* Save any updated secrets */
   if ((request->flags & NM_SECRET_AGENT_GET_SECRETS_FLAG_ALLOW_INTERACTION) ||
       (request->flags & NM_SECRET_AGENT_GET_SECRETS_FLAG_REQUEST_NEW))
     {
-      NMConnection *dup = nm_connection_duplicate (request->connection);
+      NMConnection *dup = nm_simple_connection_new_clone (request->connection);
 
-      nm_connection_update_secrets (dup, request->setting_name, request->entries, NULL);
-      nm_secret_agent_save_secrets (NM_SECRET_AGENT (self), dup, NULL, NULL);
+      nm_connection_update_secrets (dup, request->setting_name, setting, NULL);
+      nm_secret_agent_old_save_secrets (NM_SECRET_AGENT_OLD (self), dup, NULL, NULL);
       g_object_unref (dup);
     }
 
-  outer = g_hash_table_new (g_str_hash, g_str_equal);
-  g_hash_table_insert (outer, request->setting_name, request->entries);
+  g_variant_builder_init (&builder_connection, NM_VARIANT_TYPE_CONNECTION);
+  g_variant_builder_add (&builder_connection, "{s@a{sv}}",
+                         request->setting_name, setting);
 
-  request->callback (NM_SECRET_AGENT (self), request->connection, outer, NULL, request->callback_data);
+  request->callback (NM_SECRET_AGENT_OLD (self), request->connection,
+                     g_variant_builder_end (&builder_connection), NULL,
+                     request->callback_data);
 
-  g_hash_table_destroy (outer);
   g_hash_table_remove (priv->requests, request_id);
 }
 
 static void
-shell_network_agent_cancel_get_secrets (NMSecretAgent *agent,
-                                        const gchar   *connection_path,
-                                        const gchar   *setting_name)
+shell_network_agent_cancel_get_secrets (NMSecretAgentOld *agent,
+                                        const gchar      *connection_path,
+                                        const gchar      *setting_name)
 {
   ShellNetworkAgent *self = SHELL_NETWORK_AGENT (agent);
   ShellNetworkAgentPrivate *priv = self->priv;
@@ -582,12 +546,12 @@ create_keyring_add_attr_list (NMConnection *connection,
 typedef struct
 {
   /* Sort of ref count, indicates the number of secrets we still need to save */
-  gint           n_secrets;
+  gint              n_secrets;
 
-  NMSecretAgent *self;
-  NMConnection  *connection;
-  gpointer       callback;
-  gpointer       callback_data;
+  NMSecretAgentOld *self;
+  NMConnection     *connection;
+  gpointer          callback;
+  gpointer          callback_data;
 } KeyringRequest;
 
 static void
@@ -605,7 +569,7 @@ save_secret_cb (GObject           *source,
                 gpointer           user_data)
 {
   KeyringRequest *call = user_data;
-  NMSecretAgentSaveSecretsFunc callback = call->callback;
+  NMSecretAgentOldSaveSecretsFunc callback = call->callback;
 
   call->n_secrets--;
 
@@ -702,6 +666,9 @@ write_one_secret_to_keyring (NMSetting    *setting,
     }
   else
     {
+      if (!G_VALUE_HOLDS_STRING (value))
+        return;
+
       secret = g_value_get_string (value);
       if (secret && strlen (secret))
         save_one_secret (r, setting, key, secret, NULL);
@@ -709,10 +676,10 @@ write_one_secret_to_keyring (NMSetting    *setting,
 }
 
 static void
-save_delete_cb (NMSecretAgent *agent,
-                NMConnection  *connection,
-                GError        *error,
-                gpointer       user_data)
+save_delete_cb (NMSecretAgentOld *agent,
+                NMConnection     *connection,
+                GError           *error,
+                gpointer          user_data)
 {
   KeyringRequest *r = user_data;
 
@@ -727,17 +694,17 @@ save_delete_cb (NMSecretAgent *agent,
   if (r->n_secrets == 0)
     {
       if (r->callback)
-        ((NMSecretAgentSaveSecretsFunc)r->callback) (agent, connection, NULL, r->callback_data);
+        ((NMSecretAgentOldSaveSecretsFunc)r->callback) (agent, connection, NULL, r->callback_data);
       keyring_request_free (r);
     }
 }
 
 static void
-shell_network_agent_save_secrets (NMSecretAgent                *agent,
-                                  NMConnection                 *connection,
-                                  const gchar                  *connection_path,
-                                  NMSecretAgentSaveSecretsFunc  callback,
-                                  gpointer                      callback_data)
+shell_network_agent_save_secrets (NMSecretAgentOld                *agent,
+                                  NMConnection                    *connection,
+                                  const gchar                     *connection_path,
+                                  NMSecretAgentOldSaveSecretsFunc  callback,
+                                  gpointer                         callback_data)
 {
   KeyringRequest *r;
 
@@ -749,7 +716,7 @@ shell_network_agent_save_secrets (NMSecretAgent                *agent,
   r->callback_data = callback_data;
 
   /* First delete any existing items in the keyring */
-  nm_secret_agent_delete_secrets (agent, connection, save_delete_cb, r);
+  nm_secret_agent_old_delete_secrets (agent, connection, save_delete_cb, r);
 }
 
 static void
@@ -760,13 +727,13 @@ delete_items_cb (GObject *source,
   KeyringRequest *r = user_data;
   GError *secret_error = NULL;
   GError *error = NULL;
-  NMSecretAgentDeleteSecretsFunc callback = r->callback;
+  NMSecretAgentOldDeleteSecretsFunc callback = r->callback;
 
   secret_password_clear_finish (result, &secret_error);
   if (secret_error != NULL)
     {
       error = g_error_new (NM_SECRET_AGENT_ERROR,
-                           NM_SECRET_AGENT_ERROR_INTERNAL_ERROR,
+                           NM_SECRET_AGENT_ERROR_FAILED,
                            "The request could not be completed.  Keyring result: %s",
                            secret_error->message);
       g_error_free (secret_error);
@@ -778,11 +745,11 @@ delete_items_cb (GObject *source,
 }
 
 static void
-shell_network_agent_delete_secrets (NMSecretAgent                  *agent,
-                                    NMConnection                   *connection,
-                                    const gchar                    *connection_path,
-                                    NMSecretAgentDeleteSecretsFunc  callback,
-                                    gpointer                        callback_data)
+shell_network_agent_delete_secrets (NMSecretAgentOld                  *agent,
+                                    NMConnection                      *connection,
+                                    const gchar                       *connection_path,
+                                    NMSecretAgentOldDeleteSecretsFunc  callback,
+                                    gpointer                           callback_data)
 {
   KeyringRequest *r;
   NMSettingConnection *s_con;
@@ -809,7 +776,7 @@ void
 shell_network_agent_class_init (ShellNetworkAgentClass *klass)
 {
   GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
-  NMSecretAgentClass *agent_class = NM_SECRET_AGENT_CLASS (klass);
+  NMSecretAgentOldClass *agent_class = NM_SECRET_AGENT_OLD_CLASS (klass);
 
   gobject_class->finalize = shell_network_agent_finalize;
 
diff --git a/src/shell-network-agent.h b/src/shell-network-agent.h
index ab169ff..73dfe5b 100644
--- a/src/shell-network-agent.h
+++ b/src/shell-network-agent.h
@@ -4,8 +4,8 @@
 
 #include <glib-object.h>
 #include <glib.h>
-#include <nm-connection.h>
-#include <nm-secret-agent.h>
+#include <NetworkManager.h>
+#include <nm-secret-agent-old.h>
 
 G_BEGIN_DECLS
 
@@ -29,7 +29,7 @@ typedef struct _ShellNetworkAgentPrivate  ShellNetworkAgentPrivate;
 struct _ShellNetworkAgent
 {
   /*< private >*/
-  NMSecretAgent parent_instance;
+  NMSecretAgentOld parent_instance;
 
   ShellNetworkAgentPrivate *priv;
 };
@@ -37,7 +37,7 @@ struct _ShellNetworkAgent
 struct _ShellNetworkAgentClass
 {
   /*< private >*/
-  NMSecretAgentClass parent_class;
+  NMSecretAgentOldClass parent_class;
 };
 
 /* used by SHELL_TYPE_NETWORK_AGENT */
