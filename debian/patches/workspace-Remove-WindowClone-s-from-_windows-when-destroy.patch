From: =?utf-8?b?Ik1hcmNvIFRyZXZpc2FuIChUcmV2acOxbyki?= <mail@3v1n0.net>
Date: Fri, 19 Jan 2018 11:23:16 +0100
Subject: workspace: Remove WindowClone's from _windows when destroyed

A WindowClone might be destroyed earlier than its MetaWindow counterpart
as its WindowActor could be destroyed earlier, thus when happens it's safer
to remove the clone from the windows list, without waiting for the workspace
to request to do so.

WindowClone now emits a 'destroy' signals earlier enough and this now
triggers a _doRemoveWindow on WorkspaceThumbnail which will lead
to the proper cleanup; keeping track of the signal connections, in
order to avoid callback loops (not really harmful in this case, but
good practice).

Bug: https://bugzilla.gnome.org/show_bug.cgi?id=791233
Bug: https://gitlab.gnome.org/GNOME/gnome-shell/issues/1
Forwarded: https://gitlab.gnome.org/GNOME/gnome-shell/merge_requests/4
(cherry picked from commit acc8106e9a008f81b97ac302f18b465e38db352c)
---
 js/ui/workspace.js | 19 +++++++++++++++++--
 1 file changed, 17 insertions(+), 2 deletions(-)

diff --git a/js/ui/workspace.js b/js/ui/workspace.js
index fc8249a..264bd71 100644
--- a/js/ui/workspace.js
+++ b/js/ui/workspace.js
@@ -304,6 +304,8 @@ var WindowClone = new Lang.Class({
     },
 
     destroy: function () {
+        this.emit('destroy');
+
         // First destroy the clone and then destroy everything
         // This will ensure that we never see it in the _disconnectSignals loop
         this.metaWindow.disconnect(this._windowClone._updateId);
@@ -1138,6 +1140,7 @@ var Workspace = new Lang.Class({
         // Create clones for windows that should be
         // visible in the Overview
         this._windows = [];
+        this._windowsDestroyedIds = [];
         this._windowOverlays = [];
         for (let i = 0; i < windows.length; i++) {
             if (this._isOverviewWindow(windows[i])) {
@@ -1431,7 +1434,7 @@ var Workspace = new Lang.Class({
         return GLib.SOURCE_REMOVE;
     },
 
-    _doRemoveWindow : function(metaWin) {
+    _doRemoveWindow : function(metaWin, {cloneDestroy}={cloneDestroy: true}) {
         let win = metaWin.get_compositor_private();
 
         // find the position of the window in our list
@@ -1441,8 +1444,10 @@ var Workspace = new Lang.Class({
             return;
 
         let clone = this._windows[index];
+        clone.disconnect(this._windowsDestroyedIds[index]);
 
         this._windows.splice(index, 1);
+        this._windowsDestroyedIds.splice(index, 1);
         this._windowOverlays.splice(index, 1);
 
         // If metaWin.get_compositor_private() returned non-NULL, that
@@ -1460,7 +1465,9 @@ var Workspace = new Lang.Class({
                 scale: stageWidth / clone.actor.width
             };
         }
-        clone.destroy();
+
+        if (cloneDestroy)
+            clone.destroy();
 
 
         // We need to reposition the windows; to avoid shuffling windows
@@ -1807,7 +1814,11 @@ var Workspace = new Lang.Class({
             this._actualGeometryLater = 0;
         }
 
+        for (let index = 0; index < this._windows.length; ++index)
+            this._windows[index].disconnect(this._windowsDestroyedIds[index]);
+
         this._windows = [];
+        this._windowsDestroyedIds = [];
     },
 
     // Sets this.leavingOverview flag to false.
@@ -1859,6 +1870,9 @@ var Workspace = new Lang.Class({
                       Lang.bind(this, function() {
                           this._recalculateWindowPositions(WindowPositionFlags.NONE);
                       }));
+        let cloneDestroyedId = clone.connect('destroy', () => {
+            this._doRemoveWindow(clone.metaWindow, {cloneDestroy: false});
+        });
 
         this.actor.add_actor(clone.actor);
 
@@ -1870,6 +1884,7 @@ var Workspace = new Lang.Class({
             clone.setStackAbove(this._windows[this._windows.length - 1].actor);
 
         this._windows.push(clone);
+        this._windowsDestroyedIds.push(cloneDestroyedId);
         this._windowOverlays.push(overlay);
 
         return [clone, overlay];
